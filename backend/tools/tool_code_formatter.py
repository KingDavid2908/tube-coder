# backend/tools/tool_code_formatter.py
import os
import sys
import logging
import pathlib
import re
import string
import shutil
from datetime import datetime
from typing import Optional, Dict, Any
from dotenv import load_dotenv
from pydantic import BaseModel, Field
import google.generativeai as genai

# --- Logging Setup ---
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# --- Import Cancellation Helpers ---
try:
    from utils.cancellation_utils import check_cancellation, CancelledError
    CANCELLATION_ENABLED = True
except ImportError:
    tool_name = __name__.split('.')[-1]  # Get tool name for logging
    logger.error(f"Could not import cancellation checks from utils. Cancellation disabled for {tool_name}.")
    class CancelledError(Exception): pass
    def check_cancellation(session_id: str): pass
    CANCELLATION_ENABLED = False

# Import LLM Utils
try:
    from utils.llm_utils import call_gemini_api_stream_with_retries, call_gemini_with_retries
except ImportError:
    logger.warning("Could not import retry utils relatively, trying direct.")
    from llm_utils import call_gemini_api_stream_with_retries, call_gemini_with_retries

# --- Configuration ---
load_dotenv(dotenv_path=pathlib.Path(__file__).parent.parent / '.env')
GOOGLE_API_KEY = os.getenv('GOOGLE_API_KEY')
FORMATTER_MODEL_NAME = os.getenv("FORMATTER_MODEL", "gemini-2.5-pro-exp-03-25")

# Directory Setup
TEMP_BASE_DIR = pathlib.Path(os.getenv("TEMP_DATA_DIR", "./temp_youtube_data")).resolve()

# --- Markers for parsing Gemini's output ---
DIR_MARKER_START = "%%%CREATE_DIR:"
FILE_MARKER_START = "%%%START_FILE:"
FILE_MARKER_END = "%%%END_FILE:"
NAME_MARKER_START = "%%%PROJECT_NAME:"
marker_end = "%%%"

# --- Pydantic Input Schema ---
class ProjectCreationArgs(BaseModel):
    final_guide_path: str = Field(description="The absolute path to the final Markdown guide file generated by the GuideRefiner tool.")
    session_id: str = Field(description="A unique identifier for the current processing session.")

# --- Global Variables for Initialized Clients ---
_formatter_genai_configured = False
_formatter_model = None

def _initialize_formatter_gemini() -> bool:
    """Initializes the Gemini client for project formatting/structure generation."""
    global _formatter_genai_configured, _formatter_model
    if _formatter_genai_configured:
        return True
    if not GOOGLE_API_KEY:
        logger.error("GOOGLE_API_KEY not found for formatter model.")
        return False
    try:
        logger.info(f"Initializing Formatter Model ({FORMATTER_MODEL_NAME})...")
        safety_settings = [
            {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE"},
        ]
        generation_config = genai.GenerationConfig(temperature=0.3)
        _formatter_model = genai.GenerativeModel(
            FORMATTER_MODEL_NAME,
            generation_config=generation_config,
            safety_settings=safety_settings
        )
        logger.info(f"Formatter Model ({FORMATTER_MODEL_NAME}) Initialized.")
        _formatter_genai_configured = True
        return True
    except Exception as e:
        logger.exception(f"Error initializing formatter model ({FORMATTER_MODEL_NAME}): {e}")
        _formatter_genai_configured = False
        return False

# --- Helper Functions ---

def read_input_file(file_path: pathlib.Path) -> str:
    """Reads the content of the input final guide file."""
    logger.info(f"Reading final guide file: {file_path}")
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        logger.info(f"Successfully read {len(content)} characters from {file_path.name}")
        return content
    except FileNotFoundError:
        logger.error(f"Final guide file not found at '{file_path}'")
        raise
    except Exception as e:
        logger.exception(f"Error reading final guide file '{file_path}': {e}")
        raise

def construct_code_gen_prompt(final_guide_content: str) -> str:
    """Creates the prompt for Gemini to generate project name, files, and setup.txt."""
    logger.info("Constructing prompt for project structure generation...")
    name_marker_start = "%%%PROJECT_NAME:"
    dir_marker_start = "%%%CREATE_DIR:"
    file_marker_start = "%%%START_FILE:"
    file_marker_end = "%%%END_FILE:"
    marker_end = "%%%"

    prompt = f"""
    You are an expert full-stack software developer and technical writer. Your task is to generate the complete directory structure, runnable source code, and a setup guide for a software project, based **SOLELY** on the provided structured analysis file (which includes video segment analysis and a full transcript).

    **Constraints:**
    * The generated project code MUST use Google Gemini models where applicable (e.g., `ChatGoogleGenerativeAI`, `GoogleGenerativeAIEmbeddings`, model names like "gemini-pro" or "gemini-1.5-flash-latest", embedding model "models/embedding-001") and rely on the `GOOGLE_API_KEY` environment variable.
    * Assume a standard Python environment setup (e.g., using `pip` or `poetry` as indicated in the analysis).
    * Your entire response MUST strictly follow the specified Output Format using the exact markers (`%%%...%%%`). Do NOT include any other text, explanations, summaries, or conversational filler outside the marked sections.

    **Input Analysis (Contains Segment Data and Transcript):**
    ```text
    {final_guide_content}
    ```

    **Task:**
    Analyze the input text above. Based only on this input:

    **Suggest Project Name:** Determine a short, descriptive, filesystem-safe name for this project.
    **Generate Directory Structure:** Define necessary directory creation commands.
    **Generate Project Files:** Generate the complete, runnable content for all required project files (code, config, text inputs, pyproject.toml or requirements.txt, .env.example, .gitignore, __init__.py files, etc.), synthesizing information from snippets and the transcript.
    **Generate Setup Instructions:** Generate the content for a setup.txt file that explains the generated structure and provides clear steps for a user to install dependencies and run the project.

    **Output Format (Strictly Adhere):**
    Your entire response must be structured EXACTLY as follows, using the specified markers on their own lines:

    **Project Name (MUST be FIRST line):**
    {name_marker_start} suggested-project-name {marker_end}

    **Directory Creation (Optional, if needed):**
    {dir_marker_start} relative/path/to/directory {marker_end}
    (Repeat for each directory needed)

    **Project File Contents (Main part):**
    (Repeat the following block for EACH file, including .gitignore, .env.example, pyproject.toml/requirements.txt, __init__.py etc.)
    {file_marker_start} relative/path/to/file.ext {marker_end}
    # Complete file content starts here
    # ... all lines of the file ...
    # Complete file content ends here
    {file_marker_end} relative/path/to/file.ext {marker_end}

    **Setup Instructions File (MUST be the LAST file block):**
    {file_marker_start} setup.txt {marker_end}
    # Content for setup.txt starts here.
    # Explain what was generated (project name, high-level structure based on the files/dirs *you just specified above*).
    # Provide clear, numbered steps for a user:
    # 1. cd into the generated project directory (using the name you suggested).
    # 2. Create a clone of the repo (if applicable) or download the files().
    # 3. Create and activate a Python virtual environment.
    # 4. Install dependencies (infer method: 'poetry install' if pyproject.toml exists, 'pip install -r requirements.txt' if requirements.txt exists, else advise manual check).
    # 5. Set environment variables (mention copying .env.example if it exists, specifically note GOOGLE_API_KEY).
    # 6. Run the application (infer method: 'langchain serve' if app/server/server.py exists, 'python main.py/app.py' if those exist, else advise checking scripts).
    # Keep instructions concise and suitable for a plain text file.
    # Content for setup.txt ends here.
    {file_marker_end} setup.txt {marker_end}

    **Instructions for Generation:**
    Ensure the {name_marker_start}...{marker_end} line is the absolute first line.
    Infer structure, synthesize files accurately using analysis and transcript. Add necessary boilerplate (imports, if __name__ == "__main__":, etc.).
    Generate essential project files (pyproject.toml or requirements.txt, .gitignore, .env.example, __init__.py) based on context.
    Ensure correct Gemini model usage and reliance on GOOGLE_API_KEY.
    Generate the setup.txt content last, basing its instructions on the file structure you defined in the preceding output blocks.
    Generate ONLY the marked content. No extra text.

    **Begin generating the project name, structure, file contents, and setup.txt content:**
    """
    logger.info(f"Code gen prompt constructed (length: {len(prompt)} chars).")
    return prompt

def sanitize_project_name(name: str, max_length: int = 50) -> str:
    """Cleans a suggested name to be filesystem-safe."""
    if not name:
        return "unnamed_project"
    name = name.lower().strip()
    allowed_chars = string.ascii_lowercase + string.digits + "_-"
    sanitized = "".join(c if c in allowed_chars else '-' for c in name)
    sanitized = re.sub(r'-+', '-', sanitized)
    sanitized = sanitized.strip('-')
    sanitized = sanitized[:max_length]
    if not sanitized or all(c == '-' for c in sanitized):
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        return f"sanitized_project_{timestamp}"
    return sanitized

def parse_and_create_project(gemini_output: str, project_dir: pathlib.Path, session_id: str) -> Optional[str]:
    """
    Parses Gemini output using START/END file markers directly,
    taking the content between them as the file content, without
    expecting internal code fences (```).
    """
    check_cancellation(session_id)
    logger.info(f"Parsing AI response and creating project structure under: {project_dir}")
    project_dir.mkdir(parents=True, exist_ok=True)

    name_pattern_line = rf"^{re.escape('%%%PROJECT_NAME:')}.*?{re.escape(marker_end)}\s*(\r?\n)?"
    dir_pattern = re.compile(rf"^{re.escape(DIR_MARKER_START)}\s*(.*?)\s*{re.escape(marker_end)}$", re.MULTILINE)
    block_finder_pattern = re.compile(
        rf"^{re.escape(FILE_MARKER_START)}\s*(.*?)\s*{re.escape(marker_end)}\r?\n"
        rf"(.*?)\r?\n"
        rf"^{re.escape(FILE_MARKER_END)}\s*\1\s*{re.escape(marker_end)}$",
        re.MULTILINE | re.DOTALL
    )

    normalized_output = gemini_output.replace('\r\n', '\n').replace('\r', '\n')
    output_for_parsing = re.sub(name_pattern_line, '', normalized_output, count=1)

    # Create Directories
    logger.info("Creating Directories...")
    created_dirs_count = 0
    for match in dir_pattern.finditer(output_for_parsing):
        check_cancellation(session_id)
        relative_dir_path_str = match.group(1).strip().replace("\\", "/")
        if not relative_dir_path_str:
            continue
        try:
            dir_path = project_dir / pathlib.Path(relative_dir_path_str)
            if not dir_path.exists():
                dir_path.mkdir(parents=True, exist_ok=True)
                logger.info(f"Created directory: {dir_path}")
                created_dirs_count += 1
            else:
                logger.info(f"Ensured directory exists: {dir_path}")
        except CancelledError:
            raise
        except Exception as e:
            logger.warning(f"Failed to create directory '{relative_dir_path_str}': {e}")

    # Create Files
    logger.info("Creating Files...")
    created_files_count = 0
    processed_files = set()
    setup_txt_path = None
    for block_match in block_finder_pattern.finditer(output_for_parsing):
        check_cancellation(session_id)
        relative_file_path_str = block_match.group(1).strip().replace("\\", "/")
        file_content = block_match.group(2)
        if not relative_file_path_str:
            logger.warning("Found file block marker with missing path. Skipping.")
            continue
        if relative_file_path_str.startswith(('/', '\\')):
            logger.warning(f"Skipping file with absolute-looking path: '{relative_file_path_str}'")
            continue
        try:
            file_path = project_dir / pathlib.Path(relative_file_path_str)
            processed_files.add(relative_file_path_str)
            check_cancellation(session_id)
            file_path.parent.mkdir(parents=True, exist_ok=True)
            content_to_write = file_content.strip()
            check_cancellation(session_id)
            with open(file_path, 'w', encoding='utf-8', newline='\n') as f:
                f.write(content_to_write)
            logger.info(f"Created/Overwrote file: {file_path}")
            created_files_count += 1
            if relative_file_path_str == "setup.txt":
                setup_txt_path = str(file_path.resolve())
        except CancelledError:
            raise
        except Exception as e:
            logger.warning(f"Failed to write file '{relative_file_path_str}': {e}")
    if created_files_count == 0 and created_dirs_count == 0:
        logger.warning("No directory or file markers found in the Gemini response.")
        logger.debug(f"Output (first 1000 chars):\n{output_for_parsing[:1000]}")
    elif created_files_count == 0:
        logger.warning("No file content blocks were parsed, though directories might have been created.")
    if created_files_count > 0 and "setup.txt" not in processed_files:
        logger.warning("'setup.txt' was not found in the list of created files.")
    check_cancellation(session_id)
    return setup_txt_path

# --- Main Tool Function ---
def run_project_creation(
    final_guide_path: str,
    session_id: str
) -> dict:
    """
    Reads the final guide, calls Gemini to get file structure markers,
    parses the markers, creates the project files in a temporary session directory,
    and returns the path to that directory.
    """
    logger.info(f"Starting Project Creation for session: {session_id}")
    logger.info(f"Reading final guide from: {final_guide_path}")
    project_output_directory = TEMP_BASE_DIR / session_id / "generated_project"

    try:
        check_cancellation(session_id)

        if not _initialize_formatter_gemini():
            return {"status": "error", "message": "Failed to initialize Formatter LLM.", "project_directory_path": None, "setup_file_path": None}

        check_cancellation(session_id)
        guide_file = pathlib.Path(final_guide_path)
        final_guide_content = read_input_file(guide_file)
        if not final_guide_content.strip():
            logger.error("Final guide file is empty.")
            return {"status": "error", "message": "Final guide file is empty.", "project_directory_path": None, "setup_file_path": None}

        check_cancellation(session_id)
        prompt = construct_code_gen_prompt(final_guide_content)

        check_cancellation(session_id)
        logger.info("Calling Formatter LLM to get project structure markers (non-streaming)...")
        response = call_gemini_with_retries(
            model_input=prompt,
            model_instance=_formatter_model,
            model_name=FORMATTER_MODEL_NAME
        )
        check_cancellation(session_id)

        # Process response
        structure_output = None
        if hasattr(response, 'prompt_feedback') and response.prompt_feedback.block_reason:
            block_reason = response.prompt_feedback.block_reason
            logger.error(f"Formatter LLM call blocked! Reason: {block_reason}")
            raise Exception(f"Formatter LLM call blocked: {block_reason}")
        elif response.text:
            structure_output = response.text
            logger.info("Received structure response from Formatter LLM (non-streaming).")
        else:
            logger.error("Formatter LLM call succeeded but returned no text.")
            raise ValueError("Formatter LLM returned no text content.")

        check_cancellation(session_id)
        logger.info(f"Creating project files in temporary directory: {project_output_directory}")
        project_output_directory.mkdir(parents=True, exist_ok=True)
        setup_file_path_str = parse_and_create_project(structure_output, project_output_directory, session_id)

        check_cancellation(session_id)

        if setup_file_path_str:
            logger.info(f"Project structure created successfully. Setup file: {setup_file_path_str}")
            return {
                "status": "success",
                "message": "Project structure created successfully in temporary location.",
                "project_directory_path": str(project_output_directory.resolve()),
                "setup_file_path": setup_file_path_str
            }
        else:
            logger.error("Parsing structure output or creating files failed.")
            logger.debug(f"LLM Structure Output (first 500 chars):\n{structure_output[:500]}")
            return {
                "status": "error",
                "message": "Failed to parse LLM structure output or create project files.",
                "project_directory_path": str(project_output_directory.resolve()),
                "setup_file_path": None
            }

    except CancelledError as ce:
        logger.warning(f"Project Creation cancelled for session {session_id}: {ce}")
        try:
            if project_output_directory.exists():
                shutil.rmtree(project_output_directory)
                logger.info(f"Cleaned up partially created project directory: {project_output_directory}")
        except Exception as clean_e:
            logger.error(f"Failed to cleanup cancelled project directory {project_output_directory}: {clean_e}")
        return {
            "status": "cancelled",
            "message": "Processing cancelled by user.",
            "project_directory_path": str(project_output_directory.resolve()),
            "setup_file_path": None
        }
    except FileNotFoundError:
        logger.error(f"Final guide file not found at {final_guide_path}")
        return {"status": "error", "message": f"Final guide file not found: {final_guide_path}", "project_directory_path": None, "setup_file_path": None}
    except Exception as e:
        logger.exception(f"An unexpected error occurred during project creation for session {session_id}: {e}")
        return {"status": "error", "message": f"An unexpected error occurred: {e}", "project_directory_path": None, "setup_file_path": None}